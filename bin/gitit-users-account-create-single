#!/usr/bin/perl
# +---------------------------------------------------------------------------+
# | gitit-users-account-create-single                                         |
# |                                                                           |
# | Print `gitit-users` file content with a single account on the command     |
# | line after account name and mail address is given via option and a        |
# | password is provided via command line or via file.                        |
# |                                                                           |
# | This command can be used to create a `gitit-users` file with only ONE     |
# | user account entry to kick start a gitit instance via command line,       |
# | script or puppet.                                                         |
# |                                                                           |
# | CAUTION:                                                                  |
# |   The " character will not be included in the salt. This might (a)        |
# |   reduce the security a bit and (b) if you are very unlucky can make      |
# |   the script run for eternity. But if this happens you have probably      |
# |   also other problems with your karma.                                    |
# |   Note: currently, String::Random uses Perl's built-in predictable        |
# |   random number generator so the passwords generated by it are insecure.  |
# |                                                                           |
# |   To improve this situation Math::Random::Secure could be used. Probably  |
# |   better, but using the blocking /dev/random, Crypt::Random should be     |
# |   used.                                                                   |
# |                                                                           |
# | Version: 0.1.3                                                            |
# |                                                                           |
# | Changes:                                                                  |
# |                                                                           |
# | 0.1.3 2022-03-08 Christian K端lker <c@c8i.org>                             |
# |     - Ask password twice to limit typos                                   |
# | 0.1.2 2022-02-21 Christian K端lker <c@c8i.org>                             |
# |     - Add comments                                                        |
# |     - Improve " handling of pSalt                                         |
# |     - Published under https://github.com/ckuelker/gitit-tools/            |
# | 0.1.1 2021-07-31 Christian K端lker <c@c8i.org>                             |
# |     - Add read password from file name                                    |
# | 0.1.0 2020-08-23 Christian K端lker <c@c8i.org>                             |
# |     - Initial release                                                     |
# |                                                                           |
# +---------------------------------------------------------------------------+
use warnings;
use strict;
use Digest::SHA qw(sha1 sha512_hex sha512_base64);
use String::Random;
use Term::ReadKey;
use Getopt::Long;
use utf8;

# A gitit password file like `gitit-users` contains a list of hashes with
# nested account information following the following syntax pattern:
#
# [("FirstnameLastname",User {uUsername = "FirstnameLastname",\
# uPassword = Password {pSalt = "32CHAR_STR_RND_PAT",\
# pHashed = "128CHAR_STR_SALTED_SHA512_HEX"},\
# uEmail = "account@domain.tld"})
# ]

# 1 - Environment
my @opt = qw(debug email|e=s filename|f=s help username|u=s);
my $opt = {};
$opt->{debug}    = 0;
$opt->{email}    = undef;
$opt->{filename} = undef;
$opt->{help}     = 0;
$opt->{username} = undef;

# Need to die with Getopt::Long to pass error message
GetOptions( $opt, @opt ) or die( usage("Unknown command line option") );

# 2 - Checks
usage() if $opt->{help};

# 2.1 - User name (ID)
usage('No user name') if not defined $opt->{username};
my $uUsername = $opt->{username};
chomp $uUsername;
if ( $uUsername =~ m/([^a-zA-Z0-9])/ ) {
    usage("Invalid character [$1] in user name. OK: a-zA-Z0-9");
}
usage("User name too short. Use >= 3 characters") if length $uUsername < 3;

# 2.2  E-mail address
usage('No e-mail') if not defined $opt->{email};
my $uEmail = $opt->{email};
chomp $uEmail;

# Test e-mail address. Usually this should be done with Email::Valid or
# similar. But since this script is most likely be used by an experienced used
# we will just test for @
usage('E-mail without "@"') if not $uEmail =~ m/@/gmx;
usage('E-mail without "."') if not $uEmail =~ m/\./gmx;

# 3 - Password file
my $pfn       = $opt->{filename};
my $uPassword = undef;
if ( defined $pfn ) {    # read from file
    chomp $pfn;
    open my $fh, q{<}, $pfn or die "ERROR: Can not open [$pfn]\n";
    $uPassword = <$fh>;
    close $fh;
    chomp $uPassword;
}
else {                   # read from STDIN
    Term::ReadKey::ReadMode('noecho');
    print "Enter new password: ";
    my $uPassword0 = Term::ReadKey::ReadLine(0);
    print "\n";
    print "Repeat new password: ";
    my $uPassword1 = Term::ReadKey::ReadLine(0);
    Term::ReadKey::ReadMode('restore');
    print "\n";
    $uPassword0 =~ s/\R\z//;    # get rid of that pesky line ending
    $uPassword1 =~ s/\R\z//;    # get rid of that pesky line ending
    usage("Given passwords do not match") if $uPassword0 ne $uPassword1;
    $uPassword = $uPassword0;
}

# 4 - Prepare printing
my $printPassword = '*' x length $uPassword;
usage("Password too short. Use >= 6 characters") if length $uPassword < 6;

print "User name:   [$uUsername]\n"     if $opt->{debug};
print "Password:    [$printPassword]\n" if $opt->{debug};
print "Password:    [$uPassword]\n"     if $opt->{debug};
print "E-Mail:      [$uEmail]\n"        if $opt->{debug};

# 4 - Calculations: Salt, Hash
my $pat   = "." x 32;
my $salt  = String::Random->new();
my $pSalt = q{};
my $n     = 0;
my $r     = 1;
while ($r) {
    $pSalt = $salt->randpattern($pat);
    print "pSalt:       [$pSalt]\n" if $opt->{debug};
    $n++;
    last if not $pSalt =~ m/"/gmx;
}
print "pSalt count: [$n]\n" if $opt->{debug};
my $pHashed = sha512_hex( $pSalt . $uPassword );

# 5 - Print
my $string = qq/[("$uUsername",User {uUsername = "$uUsername", /;
$string .= qq/uPassword = Password {pSalt = "$pSalt", /;
$string .= qq/pHashed = "$pHashed"}, /;
$string .= qq/uEmail = "$uEmail"})\n]/;
print $string . "\n";

exit 0;

sub usage {
    my $msg = shift;
    my $L   = "=" x 80;
    my $un  = "--username=<FirstnameLastname>";
    my $em  = "--email=<EMail>";
    print "$L\nERROR:\n\t$msg!\n$L\n" if defined $msg;
    print <<"EOL";
USAGE:
  $0 $un $em
  $0 $un $em --filename=[PasswordFile]

OPTIONS:
  --debug                        : switch debug messages on (print more)
   -e                            : same as --email
  --email=<EMmail>               : e-mail address of new account
   -f                            : same as --filename
  --filename=[PasswordFile]      : name of file containing one password
  --help                         : this message
   -u                            : same as --username
  --username=<FirstnameLastname> : ID of new account

  < > options are mandatory
  [ ] options are optional

EOL
    die "$L\nERROR: $msg! $@\n" if defined $msg;
    exit 0;
}

1;
__END__
